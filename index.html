<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Star-Hub">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Star-Hub – ZIP-Version</title>
  <!-- Externe CSS-Datei -->
  <link rel="stylesheet" href="styles.css">
  <!-- JSZip zum Verarbeiten der ZIP-Datei -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
</head>
<body>
  <!-- Header "Star-hub" – wird nach Upload ausgeblendet -->
  <div id="main-header">Star-hub</div>
  <div class="container">
    <div class="content" id="main-content">
      <!-- ZIP-Datei hochladen -->
      <input type="file" id="zip-input" accept=".zip">
      <!-- Einstellungen-Button -->
      <button id="settings-button">Einstellungen</button>
      <!-- Hier werden die HTML-Dateien (und Favoriten) aufgelistet -->
      <ul id="program-list"></ul>
      <audio id="audio-player"></audio>
    </div>
    <footer id="folder-info"></footer>
  </div>
  
  <!-- Fullscreen-Container für die Anzeige -->
  <div id="fullscreen-container">
    <iframe id="fullscreen-iframe"></iframe>
    <button id="exit-fullscreen">Stop</button>
  </div>
  
  <!-- Modal für Einstellungen -->
  <div id="settings-modal">
    <div class="modal-content">
      <span class="close-modal">&times;</span>
      <h2>Einstellungen</h2>
      <div class="settings-group">
        <label for="sorting-option">Sortierung:</label>
        <select id="sorting-option">
          <option value="default">Standard</option>
          <option value="alphabetical">Alphabetisch</option>
        </select>
      </div>
      <div class="settings-group">
        <label for="music-volume">Musiklautstärke:</label>
        <input type="range" id="music-volume" min="0" max="1" step="0.01" value="0.5">
      </div>
      <div class="settings-group">
        <button id="delete-all-data">Alle Daten löschen</button>
      </div>
    </div>
  </div>
  
  <!-- Service Worker Registrierung -->
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js")
          .then(() => console.log("Service Worker registriert"))
          .catch((err) => console.log("Service Worker Fehler:", err));
    }
  </script>
  
  <!-- Haupt-Script -->
  <script>
    /* 
      Diese Version verwendet eine ZIP-Datei, die alle HTML-Dateien enthält.
      Der Upload wird über ein <input type="file"> vorgenommen. Anschließend
      werden alle HTML-Dateien (egal in welchen Unterordnern) aus der ZIP gelesen
      und in einer Liste dargestellt. Favoriten, Einstellungen und Fullscreen-Funktion
      bleiben erhalten.
    */

    // Globaler JSZip-Container
    let globalZip = null;

    // Wrapper-Funktion, um einen JSZip-Dateiobjekt in ein "fileHandle"-ähnliches Objekt zu verpacken,
    // das eine getFile()-Methode bereitstellt.
    function wrapZipFile(zipFile) {
      return {
        getFile: function() {
          return zipFile.async("blob");
        }
      };
    }

    // ZIP-Upload: Sobald eine ZIP-Datei hochgeladen wird, verarbeiten
    document.getElementById("zip-input").addEventListener("change", async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const jszip = new JSZip();
      try {
        globalZip = await jszip.loadAsync(file);
      } catch (e) {
        alert("Fehler beim Laden der ZIP-Datei: " + e.message);
        return;
      }
      // Nach erfolgreichem Upload: Verstecke ZIP-Input und Header
      document.getElementById("zip-input").style.display = "none";
      document.getElementById("main-header").style.display = "none";
      // Setze eine Version im Footer (hier einfach "ZIP" als Platzhalter)
      document.getElementById("folder-info").textContent = "Star-tools a @wolfikuproduction | version : ZIP";
      // Liste alle HTML-Dateien aus der ZIP auf
      await listHTMLFilesFromZip();
    });

    // Funktion: Listet alle HTML-Dateien aus der ZIP, unabhängig von der Ordnerstruktur, auf
    async function listHTMLFilesFromZip() {
      const programListElem = document.getElementById("program-list");
      // Leere vorhandene Einträge
      programListElem.innerHTML = "";
      const sortingOption = localStorage.getItem("sortingOption") || "default";
      let files = [];
      for (const key in globalZip.files) {
        // Ignoriere Verzeichnisse und wähle Dateien, die mit .html enden (unabhängig von Groß-/Kleinschreibung)
        if (!globalZip.files[key].dir && key.toLowerCase().endsWith(".html")) {
          // Der Titel wird aus dem Dateinamen (ohne Pfad und .html) abgeleitet
          const parts = key.split("/");
          const filename = parts[parts.length - 1];
          const title = filename.replace(/\.html$/i, "");
          files.push({ title: title, filePath: key });
        }
      }
      // Sortiere alphabetisch, falls gewünscht
      if (sortingOption === "alphabetical") {
        files.sort((a, b) => a.title.localeCompare(b.title));
      }
      // Zeige die Dateien an
      for (const file of files) {
        const li = document.createElement("li");
        li.className = "normal-program";  // Verwende das normale Design für alle
        li.textContent = file.title;
        const favId = "file_" + file.title;
        // Verwende den Wrapper, um ein "fileHandle"-ähnliches Objekt zu erstellen
        li.appendChild(createFavoriteIcon(favId, wrapZipFile(globalZip.file(file.filePath)), "normal", file.title));
        li.onclick = async () => {
          try {
            const blob = await globalZip.file(file.filePath).async("blob");
            const url = URL.createObjectURL(blob);
            await enterFullscreen(url);
          } catch (err) {
            alert("Das Spiel konnte nicht geladen werden. Es wurde möglicherweise entfernt.");
            await removeFavorite(favId);
            renderFavorites();
          }
        };
        programListElem.appendChild(li);
      }
    }

    // Vollbild-Funktion: Öffnet die URL im Iframe im Vollbildmodus
    async function enterFullscreen(url) {
      const fsContainer = document.getElementById("fullscreen-container");
      const fsIframe = document.getElementById("fullscreen-iframe");
      fsIframe.src = url;
      fsContainer.style.display = "block";
      if (fsContainer.requestFullscreen) {
        await fsContainer.requestFullscreen();
      } else if (fsContainer.webkitRequestFullscreen) {
        await fsContainer.webkitRequestFullscreen();
      } else if (fsContainer.msRequestFullscreen) {
        await fsContainer.msRequestFullscreen();
      }
    }

    document.getElementById("exit-fullscreen").addEventListener("click", async function() {
      if (document.fullscreenElement) {
        await document.exitFullscreen();
      }
      document.getElementById("fullscreen-container").style.display = "none";
    });

    // ================= IndexedDB für Favoriten =================
    function openFavoritesDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open("favoritesDB", 1);
        request.onupgradeneeded = () => {
          const db = request.result;
          db.createObjectStore("favorites", { keyPath: "id" });
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function addFavorite(fav) {
      const db = await openFavoritesDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("favorites", "readwrite");
        const store = tx.objectStore("favorites");
        const req = store.put(fav);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    async function removeFavorite(favId) {
      const db = await openFavoritesDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("favorites", "readwrite");
        const store = tx.objectStore("favorites");
        const req = store.delete(favId);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    async function getFavorite(favId) {
      const db = await openFavoritesDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("favorites", "readonly");
        const store = tx.objectStore("favorites");
        const req = store.get(favId);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function getAllFavorites() {
      const db = await openFavoritesDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("favorites", "readonly");
        const store = tx.objectStore("favorites");
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function clearAllFavorites() {
      const db = await openFavoritesDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("favorites", "readwrite");
        const store = tx.objectStore("favorites");
        const req = store.clear();
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }
    // ================= Ende Favoriten =================

    // Hier wird createFavoriteIcon definiert – verfügbar in allen Funktionen.
    function createFavoriteIcon(favId, fileHandle, type, title) {
      const span = document.createElement("span");
      span.className = "fav-icon";
      span.textContent = "☆"; // leerer Stern
      getFavorite(favId).then(fav => {
        if (fav) {
          span.textContent = "★"; // gefüllt
        }
      });
      span.addEventListener("click", async (e) => {
        e.stopPropagation();
        const fav = await getFavorite(favId);
        if (fav) {
          await removeFavorite(favId);
          span.textContent = "☆";
          renderFavorites();
        } else {
          await addFavorite({ id: favId, type, title, fileHandle });
          span.textContent = "★";
          renderFavorites();
        }
      });
      return span;
    }

    let globalFavorites = {};

    async function renderFavorites() {
      const favListElem = document.getElementById('program-list');
      const existingFavSection = document.getElementById("favorites-section");
      if (existingFavSection) {
        existingFavSection.remove();
      }
      const favorites = await getAllFavorites();
      globalFavorites = {};
      favorites.forEach(f => globalFavorites[f.id] = f);
      if (favorites.length > 0) {
        const favSection = document.createElement("div");
        favSection.id = "favorites-section";
        const header = document.createElement("div");
        header.className = "favorites-header";
        header.textContent = "Favoriten";
        favSection.appendChild(header);
        favorites.forEach(fav => {
          const li = document.createElement("li");
          li.textContent = fav.title;
          li.appendChild(createFavoriteIcon(fav.id, fav.fileHandle, fav.type, fav.title));
          li.onclick = async () => {
            try {
              const file = await fav.fileHandle.getFile();
              const url = URL.createObjectURL(file);
              await enterFullscreen(url);
            } catch (err) {
              alert("Das Spiel konnte nicht geladen werden. Es wurde möglicherweise entfernt.");
              await removeFavorite(fav.id);
              renderFavorites();
            }
          };
          favSection.appendChild(li);
        });
        const programList = document.getElementById("program-list");
        programList.prepend(favSection);
      }
    }

    // Einstellungen-Modal öffnen/schließen
    const settingsButton = document.getElementById("settings-button");
    const settingsModal = document.getElementById("settings-modal");
    const closeModal = document.querySelector(".close-modal");

    settingsButton.addEventListener("click", () => {
      settingsModal.style.display = "block";
    });
    if (closeModal) {
      closeModal.addEventListener("click", () => {
        settingsModal.style.display = "none";
        const sortingOption = document.getElementById("sorting-option").value;
        localStorage.setItem("sortingOption", sortingOption);
        const volume = document.getElementById("music-volume").value;
        document.getElementById("audio-player").volume = volume;
      });
    }
    window.addEventListener("click", (e) => {
      if (e.target === settingsModal) {
        settingsModal.style.display = "none";
        const sortingOption = document.getElementById("sorting-option").value;
        localStorage.setItem("sortingOption", sortingOption);
        const volume = document.getElementById("music-volume").value;
        document.getElementById("audio-player").volume = volume;
      }
    });

    document.getElementById("delete-all-data").addEventListener("click", async () => {
      if (confirm("Alle lokalen Daten (Favoriten, Einstellungen) wirklich löschen?")) {
        localStorage.removeItem("sortingOption");
        await clearAllFavorites();
        alert("Alle Daten wurden gelöscht.");
        renderFavorites();
      }
    });
  </script>
  
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js")
          .then(() => console.log("Service Worker registriert"))
          .catch((err) => console.log("Service Worker Fehler:", err));
    }
  </script>
</body>
</html>
