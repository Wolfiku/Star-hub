<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Star-Hub">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Spielesucher mit Einstellungen, Favoriten, Musik & Fullscreen</title>
  <!-- Externe CSS-Datei einbinden -->
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <!-- Header "Star-hub" (wird nach Ordnerauswahl ausgeblendet) -->
  <div id="main-header">Star-hub</div>
  <div class="container">
    <div class="content" id="main-content">
      <button id="select-folder">Ordner auswählen</button>
      <!-- Einstellungen-Button -->
      <button id="settings-button">Einstellungen</button>
      <ul id="program-list"></ul>
      <audio id="audio-player"></audio>
    </div>
    <footer id="folder-info"></footer>
  </div>
  
  <!-- Fullscreen-Container für die Spielanzeige -->
  <div id="fullscreen-container">
    <iframe id="fullscreen-iframe"></iframe>
    <button id="exit-fullscreen">Stop</button>
  </div>
  
  <!-- Modal für Einstellungen -->
  <div id="settings-modal">
    <div class="modal-content">
      <span class="close-modal">&times;</span>
      <h2>Einstellungen</h2>
      <div class="settings-group">
        <label for="sorting-option">Sortierung:</label>
        <select id="sorting-option">
          <option value="default">Standard</option>
          <option value="alphabetical">Alphabetisch</option>
        </select>
      </div>
      <div class="settings-group">
        <label for="music-volume">Musiklautstärke:</label>
        <input type="range" id="music-volume" min="0" max="1" step="0.01" value="0.5">
      </div>
      <div class="settings-group">
        <button id="delete-all-data">Alle Daten löschen</button>
      </div>
    </div>
  </div>
  
  <!-- Service Worker Registrierung -->
  <script>
    if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("service-worker.js")
            .then(() => console.log("Service Worker registriert"))
            .catch((err) => console.log("Service Worker Fehler:", err));
    }
  </script>
  
  <!-- Haupt-Script -->
  <script>
    // ================= IndexedDB für Favoriten =================
    function openFavoritesDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open("favoritesDB", 1);
        request.onupgradeneeded = () => {
          const db = request.result;
          db.createObjectStore("favorites", { keyPath: "id" });
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function addFavorite(fav) {
      const db = await openFavoritesDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("favorites", "readwrite");
        const store = tx.objectStore("favorites");
        const req = store.put(fav);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    async function removeFavorite(favId) {
      const db = await openFavoritesDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("favorites", "readwrite");
        const store = tx.objectStore("favorites");
        const req = store.delete(favId);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    async function getFavorite(favId) {
      const db = await openFavoritesDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("favorites", "readonly");
        const store = tx.objectStore("favorites");
        const req = store.get(favId);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function getAllFavorites() {
      const db = await openFavoritesDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("favorites", "readonly");
        const store = tx.objectStore("favorites");
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function clearAllFavorites() {
      const db = await openFavoritesDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("favorites", "readwrite");
        const store = tx.objectStore("favorites");
        const req = store.clear();
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }
    // ================= Ende Favoriten =================

    // Hier wird createFavoriteIcon definiert – verfügbar in allen Funktionen.
    function createFavoriteIcon(favId, fileHandle, type, title) {
      const span = document.createElement("span");
      span.className = "fav-icon";
      span.textContent = "☆";
      getFavorite(favId).then(fav => {
        if (fav) {
          span.textContent = "★";
        }
      });
      span.addEventListener("click", async (e) => {
        e.stopPropagation();
        const fav = await getFavorite(favId);
        if (fav) {
          await removeFavorite(favId);
          span.textContent = "☆";
          renderFavorites();
        } else {
          await addFavorite({ id: favId, type, title, fileHandle });
          span.textContent = "★";
          renderFavorites();
        }
      });
      return span;
    }

    let globalFavorites = {};

    async function renderFavorites() {
      const favListElem = document.getElementById('program-list');
      const existingFavSection = document.getElementById("favorites-section");
      if (existingFavSection) {
        existingFavSection.remove();
      }
      const favorites = await getAllFavorites();
      globalFavorites = {};
      favorites.forEach(f => globalFavorites[f.id] = f);
      if (favorites.length > 0) {
        const favSection = document.createElement("div");
        favSection.id = "favorites-section";
        const header = document.createElement("div");
        header.className = "favorites-header";
        header.textContent = "Favoriten";
        favSection.appendChild(header);
        favorites.forEach(fav => {
          const li = document.createElement("li");
          if (fav.type === "super") {
            li.className = "super-program";
          } else if (fav.type === "normal") {
            li.className = "normal-program";
          } else if (fav.type === "third") {
            li.className = "third-party-program";
          }
          li.textContent = fav.title;
          li.appendChild(createFavoriteIcon(fav.id, fav.fileHandle, fav.type, fav.title));
          li.onclick = async () => {
            try {
              const file = await fav.fileHandle.getFile();
              const url = URL.createObjectURL(file);
              await enterFullscreen(url);
            } catch (err) {
              alert("Das Spiel konnte nicht geladen werden. Es wurde möglicherweise entfernt.");
              await removeFavorite(fav.id);
              renderFavorites();
            }
          };
          favSection.appendChild(li);
        });
        const programList = document.getElementById("program-list");
        programList.prepend(favSection);
      }
    }

    async function selectFolder() {
      if (!window.showDirectoryPicker) {
        alert("Dein Browser unterstützt die File System Access API nicht.");
        return;
      }
      try {
        const mainFolderHandle = await window.showDirectoryPicker();
        const permission = await mainFolderHandle.requestPermission({ mode: 'read' });
        if (permission !== 'granted') {
          alert("Berechtigung nicht erteilt.");
          return;
        }
        return mainFolderHandle;
      } catch (e) {
        console.error("Fehler bei der Ordnerauswahl:", e);
      }
    }

    async function getNewestSubfolder(mainFolderHandle) {
      let shDataHandle;
      try {
        shDataHandle = await mainFolderHandle.getDirectoryHandle('sh-data', { create: false });
      } catch (e) {
        throw new Error("Ordner 'sh-data' nicht gefunden.");
      }
      const subfolders = [];
      for await (const entry of shDataHandle.values()) {
        if (entry.kind === 'directory') {
          const num = Number(entry.name);
          if (!isNaN(num)) {
            subfolders.push({ handle: entry, num: num });
          }
        }
      }
      if (subfolders.length === 0) {
        throw new Error("Keine passenden Unterordner (mit numerischen Namen) in 'sh-data' gefunden.");
      }
      subfolders.sort((a, b) => b.num - a.num);
      return subfolders[0].handle;
    }

    async function playRandomMusic(mediaDirHandle) {
      const mp3Files = [];
      for await (const entry of mediaDirHandle.values()) {
        if (entry.kind === 'file' && entry.name.endsWith('.mp3')) {
          mp3Files.push(entry);
        }
      }
      if (mp3Files.length === 0) {
        console.warn("Keine mp3 Dateien in ssp-media-musik gefunden.");
        return;
      }
      for (let i = mp3Files.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [mp3Files[i], mp3Files[j]] = [mp3Files[j], mp3Files[i]];
      }
      let currentIndex = 0;
      const audioPlayer = document.getElementById('audio-player');
      audioPlayer.pause();
      audioPlayer.src = "";
      async function playNext() {
        if (currentIndex >= mp3Files.length) {
          for (let i = mp3Files.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [mp3Files[i], mp3Files[j]] = [mp3Files[j], mp3Files[i]];
          }
          currentIndex = 0;
        }
        const fileEntry = mp3Files[currentIndex];
        const file = await fileEntry.getFile();
        const url = URL.createObjectURL(file);
        audioPlayer.src = url;
        audioPlayer.play();
        currentIndex++;
      }
      audioPlayer.onended = playNext;
      playNext();
    }

    async function enterFullscreen(url) {
      const fsContainer = document.getElementById("fullscreen-container");
      const fsIframe = document.getElementById("fullscreen-iframe");
      fsIframe.src = url;
      fsContainer.style.display = "block";
      if (fsContainer.requestFullscreen) {
        await fsContainer.requestFullscreen();
      } else if (fsContainer.webkitRequestFullscreen) {
        await fsContainer.webkitRequestFullscreen();
      } else if (fsContainer.msRequestFullscreen) {
        await fsContainer.msRequestFullscreen();
      }
    }

    document.getElementById("exit-fullscreen").addEventListener("click", async function() {
      const audioPlayer = document.getElementById('audio-player');
      audioPlayer.pause();
      audioPlayer.src = "";
      if (document.fullscreenElement) {
        await document.exitFullscreen();
      }
      document.getElementById("fullscreen-container").style.display = "none";
    });

    async function listPrograms(versionFolderHandle) {
      const programListElem = document.getElementById('program-list');
      const entries = [];
      for await (const entry of versionFolderHandle.values()) {
        entries.push(entry);
      }
      
      const sortingOption = localStorage.getItem("sortingOption") || "default";
      
      let superProgramDirs = entries.filter(entry => entry.kind === 'directory' && entry.name.startsWith("sshtml_"));
      let normalHtmlFiles = entries.filter(entry => entry.kind === 'file' && entry.name.endsWith('.html'));
      
      if(sortingOption === "alphabetical"){
        superProgramDirs.sort((a, b) => a.name.localeCompare(b.name));
        normalHtmlFiles.sort((a, b) => a.name.localeCompare(b.name));
      }
      
      const superPrograms = [];
      for (const spDir of superProgramDirs) {
        try {
          const gameDataHandle = await spDir.getDirectoryHandle("game-data", { create: false });
          let htmlFile = null;
          for await (const fileEntry of gameDataHandle.values()) {
            if (fileEntry.kind === 'file' && fileEntry.name.endsWith('.html')) {
              htmlFile = fileEntry;
              break;
            }
          }
          if (htmlFile) {
            const title = spDir.name.replace("sshtml_", "");
            const favId = "super_" + title;
            if (globalFavorites[favId]) continue;
            superPrograms.push({ title, fileEntry: htmlFile, dirHandle: spDir, favId });
          }
        } catch (e) {
          console.error("Fehler bei Verarbeitung von Superprogramm", spDir.name, e);
        }
      }
      
      for (const sp of superPrograms) {
        const li = document.createElement('li');
        li.className = "super-program";
        li.textContent = sp.title;
        li.appendChild(createFavoriteIcon(sp.favId, sp.fileEntry, "super", sp.title));
        li.onclick = async () => {
          try {
            const file = await sp.fileEntry.getFile();
            const url = URL.createObjectURL(file);
            await enterFullscreen(url);
            const audioPlayer = document.getElementById('audio-player');
            audioPlayer.pause();
            audioPlayer.src = "";
            try {
              const mediaDataHandle = await sp.dirHandle.getDirectoryHandle("media-data", { create: false });
              const musikHandle = await mediaDataHandle.getDirectoryHandle("ssp-media-musik", { create: false });
              playRandomMusic(musikHandle);
            } catch (e) {
              console.error("Fehler beim Laden der Musik: ", e);
            }
          } catch (err) {
            alert("Das Spiel konnte nicht geladen werden. Es wurde möglicherweise entfernt.");
            await removeFavorite(sp.favId);
            renderFavorites();
          }
        };
        programListElem.appendChild(li);
      }
      
      if (superPrograms.length > 0 && normalHtmlFiles.length > 0) {
        const separator = document.createElement('li');
        separator.textContent = "----- Normale Spiele -----";
        separator.style.textAlign = "center";
        separator.style.fontStyle = "italic";
        programListElem.appendChild(separator);
      }
      
      for (const file of normalHtmlFiles) {
        const title = file.name.replace(/\.html$/i, "");
        const favId = "normal_" + title;
        if (globalFavorites[favId]) continue;
        const li = document.createElement('li');
        li.className = "normal-program";
        li.textContent = title;
        li.appendChild(createFavoriteIcon(favId, file, "normal", title));
        li.onclick = async () => {
          try {
            const f = await file.getFile();
            const url = URL.createObjectURL(f);
            await enterFullscreen(url);
          } catch (err) {
            alert("Das Spiel konnte nicht geladen werden. Es wurde möglicherweise entfernt.");
            await removeFavorite(favId);
            renderFavorites();
          }
        };
        programListElem.appendChild(li);
      }
    }
    
    async function listThirdPartyGames(mainFolderHandle) {
      try {
        const thirdPartyHandle = await mainFolderHandle.getDirectoryHandle('sh-3party-games', { create: false });
        const entries = [];
        for await (const entry of thirdPartyHandle.values()) {
          if (entry.kind === 'file' && entry.name.endsWith('.html')) {
            entries.push(entry);
          }
        }
        if (entries.length > 0) {
          const sortingOption = localStorage.getItem("sortingOption") || "default";
          if(sortingOption === "alphabetical"){
            entries.sort((a, b) => a.name.localeCompare(b.name));
          }
          const programListElem = document.getElementById('program-list');
          const separator = document.createElement('li');
          separator.textContent = "----- 3rd Party Games -----";
          separator.style.textAlign = "center";
          separator.style.fontStyle = "italic";
          programListElem.appendChild(separator);
          for (const file of entries) {
            const title = file.name.replace(/\.html$/i, "");
            const favId = "third_" + title;
            if (globalFavorites[favId]) continue;
            const li = document.createElement('li');
            li.className = "third-party-program";
            li.textContent = title;
            li.appendChild(createFavoriteIcon(favId, file, "third", title));
            li.onclick = async () => {
              try {
                const f = await file.getFile();
                const url = URL.createObjectURL(f);
                await enterFullscreen(url);
              } catch (err) {
                alert("Das Spiel konnte nicht geladen werden. Es wurde möglicherweise entfernt.");
                await removeFavorite(favId);
                renderFavorites();
              }
            };
            programListElem.appendChild(li);
          }
        }
      } catch (e) {
        console.warn("Ordner 'sh-3party-games' nicht gefunden oder Fehler beim Laden:", e);
      }
    }

    const settingsButton = document.getElementById("settings-button");
    const settingsModal = document.getElementById("settings-modal");
    const closeModal = document.querySelector(".close-modal");

    settingsButton.addEventListener("click", () => {
      settingsModal.style.display = "block";
    });
    closeModal && closeModal.addEventListener("click", () => {
      settingsModal.style.display = "none";
      const sortingOption = document.getElementById("sorting-option").value;
      localStorage.setItem("sortingOption", sortingOption);
      const volume = document.getElementById("music-volume").value;
      document.getElementById("audio-player").volume = volume;
    });
    window.addEventListener("click", (e) => {
      if (e.target === settingsModal) {
        settingsModal.style.display = "none";
        const sortingOption = document.getElementById("sorting-option").value;
        localStorage.setItem("sortingOption", sortingOption);
        const volume = document.getElementById("music-volume").value;
        document.getElementById("audio-player").volume = volume;
      }
    });

    document.getElementById("delete-all-data").addEventListener("click", async () => {
      if (confirm("Alle lokalen Daten (Favoriten, Einstellungen) wirklich löschen?")) {
        localStorage.removeItem("sortingOption");
        await clearAllFavorites();
        alert("Alle Daten wurden gelöscht.");
        renderFavorites();
      }
    });

    document.getElementById('select-folder').addEventListener('click', async () => {
      const mainFolderHandle = await selectFolder();
      if (!mainFolderHandle) return;
      document.getElementById('select-folder').style.display = "none";
      document.getElementById('main-header').style.display = "none";
      await renderFavorites();
      try {
        const newestSubfolder = await getNewestSubfolder(mainFolderHandle);
        document.getElementById('folder-info').textContent = "Star-tools a @wolfikuproduction | version : " + newestSubfolder.name;
        await listPrograms(newestSubfolder);
        await listThirdPartyGames(mainFolderHandle);
      } catch (e) {
        console.error(e);
        alert(e.message);
      }
    });
  </script>
</body>
</html>
